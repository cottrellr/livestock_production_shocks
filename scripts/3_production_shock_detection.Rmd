---
title: "Detect shocks in livestock production"
output: html_document
---

```{r setup, include=FALSE}

library(here)
library(vroom)
library(tidyverse)
library(zoo)



source(here("scripts", "2_shock_detection_function.R"))
```

## Import tidied production data

```{r cars}
production <- tibble(readRDS(here("data", "production_tidy", "production_wo_former_nations.rds"))) %>% ungroup()


```

## Set up data for different produciton baselines (duration and mean or median) - no need to adjust span (GAM function far better at fitting first time than loess of set span).

```{r pressure, echo=FALSE}

#add baseline durations

baseline_durations <- c(3,5,7)

list_of_tibbles <- vector(mode="list", length = 3)

for(duration in baseline_durations){
  this_duration <- 
  production %>% 
  group_by(iso_3c, area, group) %>% 
  nest() %>% 
  mutate(baseline_durations = duration,
         mean = map(data, ~(rollapply(data = .$value, width = duration, FUN = mean, fill=NA, align = "right"))),
         median = map(data, ~(rollapply(data = .$value, width = duration, FUN = median, fill=NA, align = "right")))
  ) %>% 
  unnest()

  
list_of_tibbles[[duration]] <- this_duration
}



production_w_baselines <- 
  bind_rows(list_of_tibbles) %>% 
  pivot_longer(names_to = "average", values_to = "lagged_value",
               -c(iso_3c, area, group, year, unit, value, baseline_durations)) %>% 
  arrange(area, group, baseline_durations, average,  year)


```

## Detect shocks varying cooks distance
```{r}

#rules of thumb for cooks distance applicable to each time series
# 4/n = 4/59 = ~0.07
# Greater than 1 
#do a sequence between the two

cooks_distances <- seq(from =0.05, to=1, by=0.05)

shock_tibbles_list <- vector(mode="list", length = length(cooks_distances))

for(i in cooks_distances){
  
  #element
  this_element <- which(cooks_distances==i)
  
  #data frame with shock
  these_shocks <- 
  production_w_baselines %>% 
  group_by(iso_3c, area, group) %>% 
  nest() %>% 
  mutate(shock_presence = map(data, ~shock_detector_gam(target_time_series = .$value, target_cooks_distance = i))) %>% 
  unnest(cols = c(data, shock_presence)) %>% 
  mutate(cooks_distance = i)
  
  #add dataframe to list
  shock_tibbles_list[[this_element]] <- these_shocks
  
  
}
  
  
#bind the list into a single tibble

shocks_by_cooks_distance <- bind_rows(shock_tibbles_list) %>% 
  mutate(delta_production = lagged_value - value)



#export shocks data

write_csv(shocks_by_cooks_distance, file = here("data", "generated_data", "shocks_w_baselines_cooks_distance.csv"))




```

## Sensitivity analysis around cooks's distance

```{r}

#0.3 - 0.35 seems reasonable for where a small blip in the trajectory starts

sensitivity <- shocks_by_cooks_distance %>% 
  filter(shock_presence==1) %>% 
  drop_na(lagged_value) %>% 
  group_by(cooks_distance) %>% 
  summarise(n = n()) %>% 
  mutate(diff = c(0, diff(n))/lag(n))
  

ggplot(data = sensitivity, aes(x=cooks_distance, y=n))+geom_line()+geom_vline(lty=2, xintercept = 0.35)




```


## Detect shocks varying span
```{r}


spans <- seq(from =0.4, to=0.8, by=0.1)

shock_tibbles_list <- vector(mode="list", length = length(cooks_distances))

for(i in spans){
  
  #element
  this_element <- which(spans==i)
  
  #data frame with shock
  these_shocks <- 
  production_w_baselines %>% 
  group_by(iso_3c, area, group) %>% 
  nest() %>% 
  mutate(shock_presence = map(data, ~shock_detector_loess(target_time_series = .$value, target_cooks_distance = 0.3, target_span = i))) %>% 
  unnest(cols = c(data, shock_presence)) %>% 
  mutate(span = i)
  
  #add dataframe to list
  shock_tibbles_list[[this_element]] <- these_shocks
  
  
}
  
  
#bind the list into a single tibble

shocks_by_span <- bind_rows(shock_tibbles_list) %>% 
  mutate(delta_production = lagged_value - value)



#export shocks data

write_csv(shocks_by_span, file = here("data", "generated_data", "shocks_w_baselines_span.csv"))


```

